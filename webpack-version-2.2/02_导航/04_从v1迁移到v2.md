[从v1迁移到v2](https://webpack.js.org/guides/migrating/)

#从v1迁移到v2

## `resolve.root`, `resolve.fallback`, `resolve.modulesDirectories`

这些配置项被`resolve.modules`所替代。查看[解析API])(https://webpack.js.org/configuration/resolve)，了解更多。

```
resolve: {
- root: path.join(__dirname, "src"),
+ modules: [
    path.join(__dirname, "src"),
    "node_modules"
  ]
}
```

## `resolve.extensions`

这个选项不再需要传递空字符串。`resolve.enforceExtension`的行为被移除。查看[解析API])(https://webpack.js.org/configuration/resolve)，了解更多。

## `resolve.*`

这里的几个APIs被修改。因为它不常使用所以不再详细列表。查看[解析API])(https://webpack.js.org/configuration/resolve)，了解更多。

## `module.loaders` 现在改为`module.rules`

老的loader配置项被一个强大的规则系统所替代，规则系统允许配置加载器和其他选项。出于兼容性原因，老的`module.loaders`语法仍然有效，旧名称依然被解析。新的命名约定更容易理解，这是将配置名称升级到`module.rules`的理由。

```
module: {
- loaders: [
+ rules: [
    {
      test: /\.css$/,
-     loaders: [
-       "style-loader",
-       "css-loader?modules=true"
-     ]
+     use: [
+       {
+         loader: "style-loader"
+       },
+       {
+         loader: "css-loader",
+         options: {
+           modules: true
+         }
+       }
+     ]
    },
    {
      test: /\.jsx$/,
      loader: "babel-loader", // Do not use "use" here
      options: {
        // ...
      }
    }
  ]
}
```

## 链式加载器

在webpack v1中，装载器可以被链式装载。使用[rule.use](https://webpack.js.org/configuration/module#rule-use)配置选项，`use`可以设置为一个装载器队列。在webpack v1中，装载器通常通过`!`配置链式装载。这种风格仅在老式配置项`module.loaders`中支持。

```
module: {
- loaders: [{
+ rules: [{
    test: /\.less$/,
-   loader: "style-loader!css-loader!less-loader"
+   use: [
+     "style-loader",
+     "css-loader",
+     "less-loader"
+   ]
  }]
}
```

## 自动 `-looader`模块扩展功能以移除

这个版本将不再支持触发`-loader`扩展映射：

```
module: {
  rules: [
    {
      use: [
-       "style",
+       "style-loader",
-       "css",
+       "css-loader",
-       "less",
+       "less-loader"
      ]
    }
  ]
}
```

你仍然可以使用之前的方式，通过`resolveLoader.moduleExtensions`配置选项，但是我们并不推荐这么做。

```
+ resolveLoader: {
+   moduleExtensions: ["-loader"]
+ }
```

查看[\#2986](https://github.com/webpack/webpack/issues/2986)，了解修改的原因。

## `json-loader`不在被引入

当没有为一个json文件进行配置时，webpack会自动尝试使用`json-loader`加载JSON文件。

```
module: {
  rules: [
-   {
-     test: /\.json/,
-     loader: "json-loader"
-   }
  ]
}
```

为了消除webpack，nodejs和browserify环境之间的区别，[我们才决定这么做](https://github.com/webpack/webpack/issues/3363)。

## 装载器在配置中相对于上下文解析

在webpack v1中，配置装载器相对于匹配的文件进行解析。然而webpack v2配置装载器相对于`context`选项进行解析。

这样解决了一些装载器引起的重复模块的问题。（使用`npm link`或者从context以外的文件引入模块）

通过这个，你可能可以移除一些hack：

```
module: {
  rules: [
    {
      // ...
-     loader: require.resolve("my-loader")
+     loader: "my-loader"
    }
  ]
},
resolveLoader: {
- root: path.resolve(__dirname, "node_modules")
}
```

## `module.preLoaders`和`module.postLoaders`已被移除

```
module: {
- preLoaders: [
+ rules: [
    {
      test: /\.js$/,
+     enforce: "pre",
      loader: "eslint-loader"
    }
  ]
}
```

## `UglifyJsPlugin`sourceMap

`UglifyJsPlugin`的 `sourceMap`选项默认是`false`（之前默认是`true`）。这意味着如果你想要为压缩代码添加资源地图或者想要知道压缩代码错误的正确行数，你需要手动为`UglifyJsPlugin`设置`sourceMap: true`。

```
devtool: "source-map",
plugins: [
  new UglifyJsPlugin({
+     sourceMap: true  
  })
]
```

## `UglifyJsPlugin`警告

`UglifyJsPlugin`的`compress.warnings`选项默认选项是`false`（之前默认是`true`）。这意味着如果你想要看压缩警告，你必须手动设置`compress.warnings`为`true`。

```
devtool: "source-map",
plugins: [
  new UglifyJsPlugin({
+     compress: {
+       warnings: true
+     }  
  })
]
```

## `UglifyJsPlugin`压缩装载器

`UglifyJsPlugin`不再转换装载器进入压缩模式。从长远计划来说，`minimize: true`通过装载器选项去设置。查看装载器文档的相关选项。

在webpack v3或者更后面的版本中，装载器的最小化模式将被移除。

为了兼容老版本装载器，装载器可以通过插件转换最小化模式：

```
plugins: [
+ new webpack.LoaderOptionsPlugin({
+   minimize: true
+ })
]
```

## `DedupePlugin`将被移除

`webpack.optimize.DedupePlugin`已经不再需要。从你的配置文件中移除。

## `BannerPlugin` —— 突破性变化

`BannerPlugin`不在尝试两个参数，而是一个对象选项。

```
plugins: [
- new webpack.BannerPlugin('Banner', {raw: true, entryOnly: true}),
+ new webpack.BannerPlugin({banner: 'Banner', raw: true, entryOnly: true})
]
```

## `OccurrenceOrderPlugin`默认开启

在配置指定这个插件不再是必要的。

```
plugins: [
- new webpack.optimize.OccurrenceOrderPlugin()
]
```

## `ExtractTextWebpackPlugin` —— 突破性变化

为了在webpack v2中正常工作，[ExtractTextPlugin](https://github.com/webpack/extract-text-webpack-plugin)升级为v2版本。
`npm install -D extract-text-webpack-plugin`
这个插件主要的变化在于语法上的改变。

### `ExtractTextPlugin.extract`

```
module: {
  rules: [
    {
      test: /\.ss$/,
-     loader: ExtractTextPlugin.extract("style-loader", "css-loader", { publicPath: "/dist" })
+     use: ExtractTextPlugin.extract({
+       fallback: "style-loader",
+       use: "css-loader",
+       publicPath: "/dist"
+     })
    }
  ]
}
```

### `ExtractTextPlugin({options})`

```
plugins: [
- new ExtractTextPlugin("bundle.js", { allChunks: true, disable: false })
+ new ExtractTextPlugin({
+   filename: "bundle.js",
+   disable: false,
+   allChunks: true
+ })
]
```

## 默认情况下，全动态引入失败

现在仅一个表达式（require(expr)）的依赖将创建一个空的上下文，而不是完整路径的上下文。

在ES2015的模块中，像这样的代码都需要重构，否则将不能正常工作。如果不能完成，可以使用`ContextReplacementPlugin`插件去隐式映射正确的解析。

## 在cli环境和配置环境中使用自定义参数

如果你在cli中滥用自定义的参数配置，如下：

`webpack --custom-stuff`

```
// webpack.config.js
var customStuff = process.argv.indexOf("--custom-stuff") >= 0;
/* ... */
module.exports = config;
```

你可以注意到这不再被允许。现在cli将更加严格。

相反，有一个接口可以将参数传递给配置。未来的工具将依靠这个。

`webpack --env.customStuff`

```
module.exports = function (env) {
  var customStuff = env.customStuff;
  /* ... */
  return config;
}
```

查看[CLI](https://webpack.js.org/api/cli)

### `require.ensure`和AMD的`require`是异步的

如果块已经被加载，这些功能现在总是异步的，而不是同步调用回调函数。

**`require.ensure`现在取决于原生的Promise。如果在环境中使用`require.ensure`缺少这些，你将需要去polyfill。**

## 装载器配置是通过`options`

你不能再在`webpack.config.js`中配置自定义属性。这必须通过`options`配置。在webpack v2中，以下`ts`属性的配置将不再有效：

```
module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.tsx$/,
        loader: "ts-loader"
      }
    ],
    /* 这种方式在webpack v2中不会生效 */
    ts: { transpileOnly: false }
  }
}
```

### `options`是什么？

好问题。严格来说，有两种可能的方式配置webpack装载器。传统的方式是使用`options`的`query`，这是在装载器名字后面追加一个字符串。类似一个查询字符串，但实际上是一种[强大的能力](https://github.com/webpack/loader-utils#parsequery)：

```
module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.tsx$/,
        loader: "ts-loader?" + JSON.stringify({ transpileOnly: false })
      }
    ]
  }
}
```

它也是与装载器一起提供的单独指定的对象。

```
module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.tsx$/,
        loader: "ts-loader",
        options: { tanspileOnly: false }
      }
    ]
  }
}
```

## `LoaderOptionsPlugin`上下文

一些装载器需要从配置项中读取他们的上下文信息。这需要通过装载器选项去传递。相关配置请查看装载器文档。

为了保持兼容性，这些信息可以通过插件传递：

```
plugins: [
+ new webpack.LoaderOptionsPlugin({
+   options: {
+     context: __dirname
+   }
+ })
]
```

### 调试

在webpack v1中，`debug`选项用来设置装载器的调试模式。这需要通过装载器选项传递。详情查看装载器相关选项的文档。

在webpack v3版本中，装载器的调试模式将被移除。

为了保持兼容性，可以通过插件的方式来设置装载器的调试模式。

```
- debug: true,
plugins: [
+ new webpack.LoaderOptionsPlugin({
+   debug: true
+ })
]
```

## ES2015的代码分割

在webpack v1中，你可能会使用`require.ensure`方法来实现模块懒加载：

```
require.ensure([], function(require) {
  var foo = rquire('./module');
});
```
ES2015定义了`import`关键字，在运行时动态加载ES2015模块。webpack将`import()`作为一个分割点，在分割块中放置请求的模块。`import()`获取模块名称作为参数，返回一个Promise对象。

```
function onClick() {
  import("./module").then(module => {
    return module.default;
  })catch(err => {
    console.log("Chunk loading failed");
  });
}
```

好消息：现在加载一个分块失败将可以被处理掉，因为他们是都是基于Promise。

警告：`require.ensure`允许使用第三个可选参数进行块命名，但是`import()`API不支持。如果你想要需要这个功能，你可以继续使用`requrie.ensure`。

```
reuqire.ensure([], function(require) {
  var foo = require("./module");
}, "custom-chunk-name");
```

## 动态表达式

`import()`可以接受部分表达式。它的处理方式类似于CommonJS的表达式。

`import()`为每一个模块都创建一个分块。

```
function route(path, query) {
  return import('./routes/${path}/route')
    .then(route => new route.Route(query));
}
```

## 将ES2015与AMD和CommonJS混合

对于AMD和CommonJS，你可以自由地混合所有三种模块类型。在这个例子中，webpack的行为类似于babel和node-eps：

```
var book = require("./book");

book.currentPage;
book.readPage();
book.default === "This is a book";
```

```
import fs from "fs";
import { readFileSync } from "fs";

typeof fs.readFileSync === "function";
typeof readFileSync === "function";
```

重要的是，你将告诉babel不要解析这些模块标记，webpack可以使用它。你可以在你的`.babelrc`或者`babel-loader`的选项中这样设置：

**.babelrc**

```
{
  "presets": [
    ["es2015", { "modules": false }]
  ]
}
```

## Hints

不需要改变，而是机会

### 模板字符串

webpack支持在表达式中填写模板字符串。这意味着你可以在webpack结构体中放心使用它们了：

```
- require('./templates/' + name);
+ require('./teampltes/${name}');
```

### 可配置的Promise对象

现在，webpack支持冲一个配置文件中返回一个Promise对象。这允许你的配置文件进行一些异步的操作。

**webpack.config.js**

```
module.exports = function() {
  return fetchLangs().then(lang => ({
    entry: "...",
    // ...
    plugins: [
      new DefinePlugin({ LANGUADE: lang })
    ]
  }));
}
```

### 高级加载器匹配

现在，webpack支持更多的方式来匹配加载器。

```
module: {
  rules: [
    {
      resource: /filename/, // 匹配 "/path/filename.js"
      resourceQuery: /^\?querystring$/, // 匹配 "?querystring"
      issuer: /filename/ // 匹配 "/path/something.js" 如果请求来自"/path/filename.js"
    }
  ]
}
```

### 更多的CLI参数

webpack v2 添加了几个新的CLI参数：

`--define process.env.NODE_ENV="production"` 查看[DefinePlugin](https://webpack.js.org/plugins/define-plugin/)。
`--display-depth` 显示每个模块到入口点的距离。
`--display-used-exports` 显示模块的哪个`exports`被使用。
`--display-max-modules` 设置输出中显示的模块编号（默认是15）。
`-p` 定义 `process.env.NODE_ENV`为`production`。

## 装载器改变

仅与加载程序作者相关的改变。

### 缓存

现在，加载器默认会进行缓存。如果想要清除缓存，加载器必须退出。

```
// 缓存加载器
module.exports = function(source) {
- this.cacheable();
  return source;
}
```

```
// 无缓存加载器
module.exports = function(source) {
  this.cacheable(false);
  return source;
}
```

### 混合选项

webpack v1 仅支持 `JSON.stringify`作为加载器选项。webpack v2 任何JS对象类型作为加载器选项。

使用混合选项仅有一个要求。你必须有一个`ident`，使它可以被其他加载器引用。

在选项对象上有一个`ident`意味着，在加载器中可能映射这个选项对象。这里有一个例子：

`require("some-loader?by-ident!resource")`

```
{
  test: /.../,
  loader: "...",
  options: {
    ident: "by-ident",
    magic: () => Math.random()
  }
}
```

这个内联的样式不应该通过常规的代码使用，但是它经常被加载器生成的代码所使用的。`style-loader`生成一个的模块，这个模块`require`剩下的请求。

```
// style-loader 生成的代码
var addStyle = require("./add-style");
var css = require("-!css-loader?{"modules": true}!postcss-loader??postcss-ident");

addStyle(css);
```

所以你如果使用了混合选项，请告诉你的用户关于`ident`的信息。
