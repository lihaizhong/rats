[构建生产环境](https://webpack.js.org/guides/production-build/)

# 构建生产环境

这个页面解释了如何使用webpack生成生产环境。

## 自动方式

运行 `webpack -p`（或者 `webpack --optimize-minimize --define process.env.NODE_ENV="'production'"`）。这表现为以下步骤：
1. 使用`UglifyJsPlugin`精简代码
2. 运行`LoaderOptionsPlugin`，[查看文档](https://webpack.js.org/plugins/loader-options-plugin)
3. 设置Node环境变量

### 精简

`UglifyJsPlugin`是webpack的插件，它按输出顺序[压缩文件](http://lisperator.net/uglifyjs/)。这个插件支持所有的[`UglifyJS`选项](https://github.com/mishoo/UglifyJS2#usage)。在命令行上指定`--optimize-minimize`，就会添加以下插件配置：

```
const webpack = require('webpack');

module.exports = {
  plugins: [
    new webpack.optimize.UglifyJsPlugin({
      sourceMap: options.devtool && (options.devtool.indexOf('sourcemap') >= 0 || options.devtool.indexOf('sourcemap') >= 0)
    })
  ]
}
```

因此，根据[开发者选项](https://webpack.js.org/configuration/devtool)，资源映射将被生成。

### 资源映射

我们鼓励你在生产环境启用Source Maps。这有助于调试和基准测试。webpack可以将Source Maps内联到捆绑束和分割文件。

在你的配置中，用`devtool`对象设置Source Map类型。我们当前支持七种Source Maps。你可以在我们的[配置文档页](https://webpack.js.org/configuration/devtool)发现更多的信息。

推荐的选择是使用`cheap-module-source-map`，这种映射方式是每一行都有一个简单的映射。

### Node环境变量

以下方式运行`webpack -p`（或者`--define process.env.NODE_ENV="'production'"`）去调用[`DefinePlugin`](https://webpack.js.org/plugins/define-plugin)：

```
const webpack = require('webpack');

module.exports = {
  plugins: [
    new webpack.optimize.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify('production')
    })
  ]
}
```

`DefinePlugin`对原始代码进行搜索和替换操作。无论导入的代码中的`process.env.NODE_ENV`值是什么，都会被替换成`"production"`。因此，类似`if (process.env.NODE_ENV !== 'production') console.log('...')`的判断都会被判定为`if (false) console.log('...')`，并且最终都会执行`UglifyJS`压缩代码。

## 手动方式：为多个环境配置webpack

当我们为多个环境有不同配置时，最容易的方式是为每个环境都写一个独立的文件。例如：

**dev.js**

```
module.exports = function (require) {
  return {
    devtool: 'cheap-module-source-map',
    output: {
      path: path.join(__dirname, '/../dist/assets'),
      filename: '[name].bundle.js',
      publicPath: publicPath,
      sourceMapFilename: '[name].map'
    },
    devServer: {
      port: 7777,
      host: 'localhost',
      historyApiFallback: true,
      noInfo: false,
      stats: 'minimal',
      publicPath: publicPath
    }
  }
}
```

**prod.js**

```
module.exports = function (env) {
  return {
    output: path.join(__dirname, '/../dist/assets'),
    filename: '[name].bundle.js',
    publicPath: publicPath,
    sourceMapFilename: '[name].map'
  },
  plugins: [
    new webpack.LoaderOptionsPlugin({
      minimize: true,
      debug: false
    }),
    new webpack.optimize.UglifyJsPlugin({
      beautify: false,
      mangle: {
        screw_ie8: true,
        keep_fnames: true
      },
      compress: {
        screw_ie8: true
      },
      comments: false
    })
  ]
}
```

webpack.config.js片段：

```
function buildConfig(env) {
  return require('./config/' + env + '.js')(env)
}

module.exports = buildConfig;
```

这是我们的package.json，我们用webpack构建我们的应用程序，下面是我们的指令集：

```
"build:dev": "webpack --env=dev --progress --profile --colors",
"build:dist": "webpack --env=prod --process --profile --colors"
```

你可以看到我们把环境变量传递给了webpack.config.js。我们通过传递变量来完成环境的切换，从而加载正确的JS文件。

一个更加好的方法是有一个基础配置文件，包括了所有公共的功能，然后有一个指定环境的文件，最后用`webpack-merge`将它们合并。这样避免了代码重复。例如，你可以在这个基础文件配置解析你的js，ts，png，jpeg，json等等。具体代码如下：

**base.js**

```
module.exports = function() {
  return {
    entry: {
      'polyfill': './src/polyfill',
      'vendor': './src/vendor.ts',
      'main': './src/main.ts'
    },
    output: {
      path: path.join(__dirname, '/../dist/assets'),
      filename: '[name].bundle.js',
      publicPath: publicPath,
      sourceMapFilename: '[name].map'
    },
    resolve: {
      extensions: ['.ts', '.js', '.json'],
      modules: [path.join(__dirname, 'src'), 'node_modules']
    },
    module: {
      rules: [
        {
          test: /\.ts$/,
          use: [
            'awesome-typescript-loader',
            'angular2-template-loader'
          ],
          exclude: [/\.(spec|e2e)\.ts$/]
        },
        {
          test: /\.css$/,
          use: ['to-string-loader', 'css-loader']
        },
        {
          test: /\.(woff|woff2|eot|ttf|svg)$/,
          use: {
            loader: 'url-loader',
            options: {
              limit: 100000
            }
          }
        }
      ]
    },
    plugins: [
      new ForkCheckerPlugin(),
      new webpack.optimize.CommonsChunkPlugin({
        name: ['polyfills', 'vendor'].reverse()
      }),
      new HtmlWebpackPlugin({
        template: 'src/index.html',
        chunksSortMode: 'dependency'
      })
    ]
  };
}
```

使用`webpack-merge`将基础文件和指定的环境配置文件合并。让我们看一下我们合并我们的生产环境文件的例子。

**prod.js(updated)**

```
const webpackMerge = require('webpack-merge');

const commonConfig = require('./base.js');

module.exports = function(env) {
  return webpackMerge(commonConfig(), {
    plugins: [
      new webpack.LoaderOptionsPlugin({
        minimize: true,
        debug: false
      }),
      new webpack.DefinePlugin({
        'process.env': {
          'NODE_ENV': JSON.stringify('production')
        }
      }),
      new webpack.optimize.UglifyJsPlugin({
        beautify: false,
        mangle: {
          screw_ie8: true,
          keep_fnames: true
        },
        compress: {
          screw_ie8: true
        },
        comments: false
      })
    ]
  });
}
```

你可能注意到`prod.js`文件有三个主要变化：

- 使用`webpack-merge`合并`base.js`
- 我们将`output`属性移到了`base.js`中。这里只是强调我们的`output`属性，这里，`output`属性在所有环境的配置一致，我们重重构了`prod.js`，将这个属性移到了`base.js`中。
- 我们用`DefinePlugin`定义`process.env.NODE_ENV`默认是`production`。当我们在生产环境构建应用程序时，通过应用程序读取`process.env.NODE_ENV`的值`production`。同样的，通过这种方法，我们可以管理我们选择的多种值来指定环境。

然而，在所有环境中的基础配置设置取决于你。当你构建我们的应用程序，我们有演示一些典型的基础配置。
