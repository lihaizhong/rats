[代码分割——库](https://webpack.js.org/guides/code-splitting-libraries/)

一个典型的应用程序经常需要使用第三方库或者插件。而且使用的版本是特定的，不会经常变换。但是，应用程序本身的代码确实频繁改变的。

将第三方代码与应用程序代码捆绑在一起会显得低效。因为浏览器可以根据缓存头来缓存资源文件，如果资源内容没有改变，文件可以不需要再次调用CDN获取。要利用这个优点，无论应用程序代码如何变化，保持第三方文件hash值不变。

仅仅只是当我们分割第三方库和应用程序代码时，我们才这么做。

让我们想想一个简单的应用程序（使用了momentjs）。

使用以下命令安装`moment`。

`npm install -S moment`

主文件将需要依赖`moment`，打印当前时间。

**index.js**

```
var moment = require('moment');
console.log(moment().format());
```

我们可以使用下面的webpack配置来捆绑应用程序

**webpack.config.js**

```
var path = require('path');

module.exports = function(env) {
  return {
    entry: './index.js',
    output: {
      filename: '[name].[chunkhash].js',
      path: path.resolve(__dirname, 'dist')
    }
  }
}
```

当你运行`webpack`后，如果你检查捆绑结果，你会发现`moment`和`index.js`都被捆绑在`bundle.js`文件中。

这不是我们想要的。如果`index.js`的代码改变，整个捆绑都将被重构。浏览器不得不去下载整个全新的捆绑束。

## 多文件入口

为`moment`或者其他第三方库添加一个入口点来解决这个问题。

**webpack.config.js**

```
var path = require('path');

module.exports = function(env) {
  return {
    entry: {
      main: './index.js',
      vendor: 'moment'
    },
    output: {
      filename: '[name].[chunkhash].js',
      path: path.resolve(__dirname, 'dist')
    }
  }
}
```

现在运行`webpack`，我们可以观察到有两个捆绑束被创建。如果你检查一下，会发现这两个文件中都存在`moment`代码！原因在于应用程序的依赖，每个入口点将捆绑其自身的依赖关系。

由于这个原因，我们需要使用[`CommonsChunkPlugin`](https://webpack.js.org/plugins/commons-chunk-plugin)。

### CommonsChunkPlugin

这是一个比较复杂的插件。从根本上来说，它允许我们从不同的捆绑束中提取所有公共模块，并将它们添加到公共捆绑束中。如果一个公共捆绑束不存在，它就会创建。

我们可以按照下面的方式修改webpack配置：

**wbepack.config.js**

```
var webpack = require('webpack');
var path = require('path');

module.exports = function(env) {
  return {
    entry: {
      main: './index.js',
      vendor: 'moment'
    },
    output: {
      filename: '[name].[chunkhash].js',
      path: path.resolve(__dirname, 'dist')
    },
    plugins:[
      new webpack.optimize.CommonsChunkPlugin({
        name: 'vendor' // 指定公共捆绑束的名称
      })
    ]
  }
}
```

现在运行`webpack`，`moment`只存在于第三方捆绑束中。

## 隐式的公共第三方块

你可以配置已个`CommonsChunkPlugin`实例，仅接受第三方库。

**webpack.config.js**

```
var webpack = require('webpack');
var path = require('path');

module.exports = function(env) {
  return {
    entry: {
      main: './index.js'
    },
    output: {
      filename: '[name].[chunkhash].js',
      path: path.resolve(__dirname, 'dist')
    },
    plugins: [
      new webpack.optimize.CommonsChunkPlugin({
        name: 'vendor',
        minChunks: function (module) {
          return module.context && module.context.indexOf('node_module') == -1;
        }
      })
    ]
  }
}
```

## Manifest文件

但是，如果你改变应用程序代码，然后再次运行`webpack`，你可以看到第三方文件的hash值改变了。虽然我们实现了分割第三方库和应用程序代码，但是我们应用程序代码的改变也会影响第三方库的hash值。这意味着我们仍然不能利用浏览器缓存。

问题在于当每一次构建，webpack会生成一些webpack运行时代码，它们会帮助webpack完成一些任务。当有单个捆绑束时，运行时代码驻留在它里面。但是当生成多个捆绑束时，运行时代码会被公共模块提取，在这里就是`vendor`文件。

为了防止这种情况的发生，我们需要提取运行时代码到一个manifest文件中。虽然我们又多创建了一个捆绑束，但是这样的开销有利于浏览器缓存，所以是值得的。

**webpack.config.js**

```
var webpack = require('webpack');
var path = require('path');

module.exports = function(env) {
  return {
    entry: {
      main: './index.js',
      vendor: 'moment'
    },
    output: {
      filename: '[name].[hashchunk].js',
      path: path.resolve(__dirname, 'dist')
    }
  },
  plugins: [
    new webpack.optimize.CommonsChunkPlugin({
      names: ['vendor', 'manifest'] // 指定公共捆绑束的名称
    })
  ]
}
```

根据以上webpack配置，我们看到三个捆绑束代码生成。`vendor`，`main`和`manifest`。

使用我们至今所学的内容，我们也能实现同样的结果。

**webpack.config.js**

```
var webpack = require('webpack');
var path = require('path');

module.exports = function(env) {
  return {
    entry: {
      main: './index.js' 、、 注意我们没有显示的vendor入口
    },
    output: {
      filename: '[name].[chunkhash].js',
      path: path.resolve(__dirname, 'dist')
    },
    plugins: [
      new webpack.optimize.CommonsChunkPlugin({
        name: 'vendor',
        minChunks: function (module) {
          // 假定你的第三方库在node_module目录下
          return module.context && module.context.indexOf('node_module') !== -1';
        }
      }),
      // CommonsChunkPlugin将提取所有的公共模块（vendor&main）
      new webpack.optimize.CommonsChunkPlugin({
        // 因为没有更多的模块，我们最终只会在manifest文件中包含运行时代码
        name: 'manifest'
      })
    ]
  }
}
```
