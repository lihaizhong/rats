[开始](https://webpack.js.org/guides/get-started/)

# 开始

webpack是一个为你的应用程序构建JavaScript模块的工具。以下是[安装教程](https://webpack.js.org/guides/installation)，我们会通过学习cli和API来了解webpack。webpack通过快速构建依赖图以及按正确的顺序绑定他们来简化你的工作流。webpack可以配置优化你的代码，为生产环境分割第三方插件/CSS/JS代码，运行一个热部署的服务器，以及大量很酷的特性。[学习更多](https://webpack.js.org/guides/why-webpack)。

## 创建一个绑定

创建一个演示目录去尝试使用webpack。

```
mkdir webpack-demo && cd webpack-demo
npm init -y
npm install --save-dev webpack
```

```
./node_modules/.bin/webpack --help # 显示有效的cli命令
.\node_modules\.bin\webpack --help # windows 用户
webpack --help # 如果你全局安装
```

现在创建一个包含`index.js`文件的子目录`app`。

**app/index.js**

```
function component () {

  var element = document.createElement('div');

  element.innerHTML = _.join(['Hello', 'webpack'], '');

  return element;
}

document/body.appendChild(component());
```

运行这个代码片段，创建`index.html`到项目根目录。

**index.html**

```
<html>
  <head>
    <title>webpack 2 demo</title>
    <script src="https://unpkg.com/lodash@4.16.6"></script>
  </head>
  <body>
    <script src="app/index.js"></script>
  </body>
</html>
```

在这个例子中，`<script>`标签中存在隐式依赖关系。

在这张页面运行时，`index.js`依赖`loadash`文件。因为`index.js`不必为`loadash`声明，所以他是隐式的。这是假定一个全局的`_`变量的存在。

这种方式管理JavaScript会有一定的问题：

- 如果依赖文件不存在或者引入顺序错误，应用程序根本不起作用。
- 如果依赖文件被引入，但是没有被使用，将会有不必要的代码被浏览器下载。

将`loadash`依赖项绑定到`index.js`，首先我们需要安装`loadash`：

```
npm install --save loadash
```

并且引入它。

**app/index.js**

```
+ import _ from 'loadash';

function component () {
  ...
}
```

我们也需要改变`index.html`文件，绑定一个简单的js文件。

```
<html>
  <head>
    <title>webpack 2 demo</title>
-   <script src="https://unpkg.com/lodash@4.16.6"></script>
  </head>
  <body>
-   <script src="app/index.js"></script>
+   <script src="dist/bundle.js"></script>
  </body>
</html>
```

这里，`index.js`下引入了`loadash`，并且用`_`（不是全局变量，而是局部变量）绑定。

通过声明一个模块需要依赖什么模块，webpack可以用这个信息去构建一个依赖图。通过这个图，webpack会生成一个优化过的绑定，脚本会在正确的位置执行，没有使用的依赖也不会被引入。

现在在带有`index.js`入口文件和`bundle.js`输出文件的文件夹下运行`webpack`

```
./node_modules/.bin/webpack app/index.js dist/bundle.js

Hash: ff6c1d39b26f89b3b7bb
Version: webpack 2.2.0
Time: 385ms
    Asset    Size  Chunks                    Chunk Names
bundle.js  544 kB       0  [emitted]  [big]  main
   [0] ./~/lodash/lodash.js 540 kB {0} [built]
   [1] (webpack)/buildin/global.js 509 bytes {0} [built]
   [2] (webpack)/buildin/module.js 517 bytes {0} [built]
   [3] ./app/index.js 278 bytes {0} [built]
```

在浏览器中打开`index.html`页面查看结果，可以观察到绑定成功了。你应该看到一个页面出现了'Hello Webpack'的一样。

## 在webpack中使用ES2015模块

你是否注意到了在`app/index.js`中ES2015模块引入的用法？虽然`import/export`语法至今不被浏览器支持，但是你可以放心使用它，因为webpack会使用ES5兼容的方式替换它。你可以检查下`dist/bundle.js`验证这个说法。

## 使用webpack配置项

对于大量复杂的配置，我们可以使用一个配置文件。webpack可以对的配置做映射。在你创建一个`webpack.config.js`文件之后，你可以用以下的配置项来代替cli命令。

**webpack.config.js**

```
var path = require('path');

module.exports = {
  entry: './app/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
};
```

以下是这个文件的运行结果：

```
./node_modules/.bin/webpack --config webpack.config.js

Hash: ff6c1d39b26f89b3b7bb
Version: webpack 2.2.0
Time: 390ms
    Asset    Size  Chunks                    Chunk Names
bundle.js  544 kB       0  [emitted]  [big]  main
   [0] ./~/lodash/lodash.js 540 kB {0} [built]
   [1] (webpack)/buildin/global.js 509 bytes {0} [built]
   [2] (webpack)/buildin/module.js 517 bytes {0} [built]
   [3] ./app/index.js 278 bytes {0} [built]
```

配置孕检允许使用webpack所有特性。我们可以添加加载器规则，插件，解析器选项和大量其他的配置。

## 用npm使用webpack

鉴于从cli运行webpack的方式不是特别的有趣，我们可以设置一个快捷方式。像下面这样，适配_package.json_：

```
{
  ...
  "scripts": {
    "build": "webpack"
  },
  ...
}
```

你可以使用`npm run build`方法实现上面的方法。

## 结论

现在已经有了构建webpack项目的基础，你应该深入学习webpack[基础](https://webpack.js.org/concepts)和[配置](https://webpack.js.org/configuration)，从而理解它的设计理念。另外可以参阅[指南](https://webpack.js.org/guides)，了解如何解决常见问题。[API](https://webpack.js.org/api)章节将深入更底层的功能。
