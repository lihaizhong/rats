[配置](https://webpack.js.org/concepts/configuration/)

# 配置

你可能注意到，很少有webpack配置看起来完全相同。这是因为webpack的配置文件是一个导出对象的配置文件。webpack会基于这个对象定义的属性来处理这个对象。

因为它是标准Node.js CommonJS模块，你可以完成一下操作：

+ 通过`require(...)`导入其他文件
+ 通过`require(...)`导入npm的公共模块
+ 使用JavaScript控制流表达式`?:`操作符
+ 对常用值使用常量或者变量
+ 写和执行方法来生成一部分配置

适时地使用这些特征

**你不应该做以下事情。**从技术上来说，你应该使用它们，但是我们不推荐使用。

+ 当使用webpack cli时，使用cli参数。（编写你自己的cli，或者使用 `--env`）
+ 导出不确定的值。（调用两次webpack，应该导致同样的输出文件）
+ 写一份冗长的配置文件。（应该将配置文件拆分成多个文件）

以下配置文件描述了如何编写既可描述的又可配置的webpack文件，这是代码：

## 一个最简单的配置文件

**webpack.config.js**

    var path = require('path');

    module.exports = {
      entry: '/foo.js',
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'foo.bundle.js'
      }
    };

## 多目标

**webpack.config.js**

    var path = require('path');
    var webpack = require('webpack');
    var webpackMerge = require('webpack-merge');

    var baseConfig = {
      target: 'async-node',
      entry: {
        entry: './entry.js'
      },
      output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js'
      },
      plugins: [
        new webpack.optimize.CommonsChunkPlugins({
          name: 'inline',
          filename: 'inline.js',
          minChunk: Infinity
        }),
        new webpack.optimize.AggressiveSlipttingPlugins({
          minSize: 5000,
          maxSize: 10000
        })
      ]
    };

    let targets = ['web', 'webworker', 'node', 'async-node', 'node-webkit', 'electron-main'].map((target) => {
      let base = webpackMerge(baseConfig, {
        target: target,
        output: {
          path: path.resolve(__dirname, 'dist/' + target),
          filename: '[name].' + target + '.js'
        }
      });

      return base;
    });

    module.exports = targets;

## 使用TypeScript

## 使用JSX
