[热部署替换](https://webpack.js.org/concepts/hot-module-replacement/)

# 热部署替换

当一个页面不需要刷新的情况下，热部署替换、添加、移除模块。这将提高你的开发效率。

## 它怎么工作

### 通过应用程序视图

1. 应用程序询问HMR运行时检查更新。
2. HMR异步下载更新，并且告诉应用程序更新成功。
3. 应用程序询问HMR运行时运行更新的代码。
4. HMR运行时运行更新的代码。

你可以设置HMR运行时自动处理，你也可以选择运行交互时更新。

### 通过编译器（webpack）视图

除正常资源外，编译器需要触发“更新”，用新版本替换老版本。“更新”有两部分组成：

1. 更新的manifest（JSON）
2. 一个或者多个更新块（JavaScript）

manifest包含了新的编译hash和所有更新块列表。

每一个更新块包含相应块中所有更新模块的代码（或者一个模块被移除的标识）

编译器确定这些模块ID和分块ID在这些构建器中一致。通常这些都是存在内存中的。（例如，使用[webpack-dev-server](https://webpack.js.org/configuration/dev-server/)）,当然他们也可能存储在JSON文件中。

### 通过模块视图

HMR有一个选择加入功能，它仅支持包含HMR代码的模块。例如[`style-loader`](https://github.com/webpack/style-loader)加载样式补丁。为了让补丁工作，`style-loader`实现了HMR接口；当接收到HMR的更新请求时，它会用新样式覆盖老样式。

同样地，当在一个模块中实现HMR接口，当模块更新时，你可以描述到底发生了什么。然而大部分情况下，我们不会强制每一个模块去编写HMR模块。如果模块没有HMR句柄，更新将会冒泡。这意味着一个句柄会处理一个模块树的更新。如果一个模块被更新，那么整个模块树都会被重载（仅重载，不转让）。

### 通过HMR运行时视图

对于模块系统运行时，追踪模块的`parents`和`children`去触发附加代码。

在管理方面，HMR运行时支持两种方式：`check`和`apply`。

`create`创造一个HTTP请求，更新manifest。如果请求失败，则更新无效；否则，更新块的列表会和当前载入块的进行比较。所有的模块更新将存储在运行时。当所有的更新块被下载并且将被应用时，运行时将切换到`ready`状态。

`apply`方法标记所有的更新模块是无效的。对于每一个无效的模块，都需要他们自己或者父祖级有更新句柄。否则，无效的标志将冒泡到父祖级，将他们也置为无效。冒泡将到应用程序入口模块或者第一个更新处理句柄被触发为止。如果冒泡到入口文件，处理失败。

之后，所有无效模块被暴露出来（通过暴露句柄），并且未被加载。当前的hash将被更新，所有的句柄都将被调用。运行时将切换到`idle`状态。

### 我能用它做什么

你可以在开发时将它视为一个LiveReload。[`webpack-dev-server`](https://webpack.js.org/configuration/dev-server/)支持热模式更新代码。看看如何实现[HMR with React](https://webpack.js.org/guides/hmr-react)。

一些加载器已经实现了热更新模块。例如，`style-loader`可以随时转换样式脚本。对于这样的模块，你不需要多做什么。

webpack的能力在于它的可定制化，在项目需要的地方，可以有多种方式配置HMR依赖。
